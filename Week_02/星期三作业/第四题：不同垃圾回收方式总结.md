# 二、不同垃圾回收方式总结

#### 1、串行化GC(SerialGC)
使用年轻代使用复制-清除，老年代使用标记-清除-整理方式进行垃圾回收，进行垃圾回收时应用系统全线暂停（STW:stop the world），单线程串行化进行垃圾回收。


#### 2、并行化GC(ParallelGC)
一种为适用于高吞吐量的应用场景而设计的GC算法。并行化GC相比于串行化大大提高了GC的效率，在多核系统上有着较强的优势，可以指定多个线程同时进行GC操作。与串行化一样在进行GC的时候也是全线暂停，由于多线程并行能够大大缩短业务暂停时间。


#### 3、CMS GC（ConcMarkSweepGC) 
CMSGC 总共分为6个阶段，在并行GC的基础上进一步缩短业务暂停时间。进行GC时主要分为以下几步：
> - Inital Mark 初始标记阶段 （不暂停业务，独立线程作业）
> 
为了收集应用程序的对象引用，需要暂停应用程序线程，阶段结束后应用线程启动。
> - Concurrent Mark 并发标记 （STW)

> 从第一阶段收集的对象引用开始，遍历所有其他的对象引用

> - Concurrent Preclean 并发预清除

> 对第二阶段已经标记的对象进行处理

> - Final remark 最终标记 （STW）

> 由于第二阶段业务线程与GC线程并发，对象引用关系可能发生变化。因此在此暂停业务线程对对象引用进行遍历确认。

> - Concurrent Sweep 并发清除

> 所有不在被引用的对象在这一阶段被并行清除

> - Concurrent Reset   并发重置

> 收集器进行收尾，比如清除计数器等，以便进行下次GC周期



#### 4、G1 GC 
jdk 9  之后模式垃圾回收器为G1。适用于大内存（>6G)、低延迟(<0.5S)、高吞吐量的场景。在分代上属于分代型垃圾回收器，也分成年轻代和老年代，不需要物理上保持分区连续，只要保证逻辑上的连续即可。具有以下特性：
> - 并行性：垃圾回收期间，可以有效的利用多核的计算能力。
> - 并发性：业务线程和GC线程可以交替执行，不会导致长时间的阻塞
> - 分代GC：同时兼顾老年代和年轻代
> - 空间整理：GC时会适当的压缩对象，整理碎片空间，若干次GC后压缩region 
> - 可预见性：有选择性的对区域进行回收，缩小了每次GC的范围



G1的堆内存由若干个大小相等的区域（region)，每个区域的大小为2的次幂，可通过参数
-XX：G1HeapRegionSize 进行设置。某个区域被填满后，下次分配内存室会从空闲区域分配。
G1 进行GC的六个阶段：

1. 初始标记阶段：停下所有所有java程序,然后开始标记根节点所有对象，这个阶段可以和年轻代回收同时回收执行。
1. 根区间扫描阶段：根区间扫描阶段也会和java程序并行执行，基于标记算法，对象从Eden区复制到Survivor区的对象需要被扫描并标记为根元素。
1. 并行标记阶段：并行标记是一个并行的且多线程的阶段，可以通过选项-XX：ConGCThreads来设置并行线程的数量，并行标记每次只扫描一个区间然后通过标记位的方式标记该区间以被扫描。
1. 重标记阶段：重标记是独占式在这个阶段主要是统计存活对象，同时对引用进行处理，G1采用多线程的方式处理日志缓存。如果java应用程序使用了大量的引用对象，那么这个从标记阶段耗时会增加。
1. 清除阶段：知道了region的存活对象那么就可以很快速的清除RSet，并且快速放入空闲区间队列而不是放入排序队列，在一个混合垃圾回收暂停阶段，RSet被用来检测过期引用，如果一个对快对象全部死亡那么就可以快速清除这个RSet。清除阶段会识别并处理空闲区域，它是并发的清理，不会引起停顿。
